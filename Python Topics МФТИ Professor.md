## Темы, рассмотренные на лекции №1:

Что есть «информатика» и что понимает под этим лектор

Что значит «уметь программировать»

Hello, World!

Концепция присваивания в Python

Обмен двух переменных значениями через одну временную и две временные переменные.

Множественное присваивание в кортежи переменных.

Обмен значений.

Арифметические операции. Возведение в степень, деление нацело.

Цикл while. Инструкции управления циклом.

Вложенный цикл while

Условный оператор if

Цикл for и его особенности в Python.

Функция range()

Оператор continue



## Темы, рассмотренные на лекции №2:

Основы алгебры логики.

Таблицы истинности и логически законы.

Дизъюнктивная нормальная форма.

Тип данных bool. Константы True, False. Логические операции в Python.

Проверка последовательности на наличие числа x%10==0.

Проверка последовательности на то, что все числа делятся на 10.

Последовательные и вложенные условные инструкции.

Каскадные условные инструкции, оператор elif.


## Темы, рассмотренные на лекции №3:

Позиционные системы счисления

Литералы чисел в Python

Разложение числа на цифры.

Однопроходные алгоритмы без реализации.



## Темы, рассмотренные на лекции №4:

Описание простых функций с параметрами.

Декомпозиция задачи.

Структурное программирование. Проектирование «сверху-вниз».

Стек вызовов.

Полиморфизм в Python. Duck typing.

Значения параметров по умолчанию.

Именованные параметры функций

Мастер-класс по структурному программированию на проекторе

Метод грубой силы.

Тест простоты числа.

Разложение числа на множители.







## Темы, рассмотренные на лекции №5:



Список как массив данных.

Линейный поиск в массиве.

Копирование массива. Копирование задом-наперёд.

Алгоритм обращения массива.

Алгоритм циклического сдвига в массиве.

Добавление элемента в конец и в начало массива.

Удаление элемента из конца и начала массива.

Ссылочная модель данных в Python. Изменяемость списка.

Решето Эратосфена.





## Темы, рассмотренные на лекции №6:





Методы append(), pop() и функция len() для списка.

Списковые включения.

Мастер-класс по TDD.

Сортировка вставками.

Сортировка выбором.

Сортировка методом пузырька.

Сортировка подсчётом.






## Темы, рассмотренные на лекции №7:



Рекурсия.


Сказка «Репка» и изготовление матрёшки.

Прямой и обратный ход рекурсии.

Фрактальный квадрат в квадрате.

Факториал числа.

Алгоритм Евклида.

Быстрое возведение в степень.

Ханойские башни.



## Темы, рассмотренные на лекции №8:



Генерация комбинаторных объектов.

Рекурсивная генерация всех чисел длины M.

Генерация всех перестановок (рекурсивная).

Быстрые сортировки: Тони Хоара и слиянием (без реализации).





## Темы, рассмотренные на лекции №9:



Быстрая сортировка Тони Хоара (реализация).

Слияние двух упорядоченных массивов.

Сортировка слиянием (реализация).

Устойчивость сортировок.

Проверка упорядоченности массива за O(N).





## Темы, рассмотренные на лекции №10:





Вычисление чисел Фибоначчи и проблема перевычислений.

Одномерное динамическое программирование на примере чисел Фибоначчи.

Задачи о кузнечике (количество траекторий, траектория наименьшей стоимости).

Двумерные массивы (списки списков).

Оператор is.



## Темы, рассмотренные на лекции №11:





Двумерное динамическое программирование.

Наибольшая общая подпоследовательность.

Наибольшая возрастающая подпоследовательность.





## Темы, рассмотренные на лекции №12:



Расстояние Левенштейна

Проверка равенства строк

Наивный поиск подстроки в строке

Алгоритм Кнута-Морриса-Пратта



## Темы, рассмотренные на лекции №13:



Стек

Автоматическое тестирование функций модуля (библиотека doctest)

Проверка корректности скобочной последовательности

Обратная Польская нотация





##  Темы, рассмотренные на лекции №14:



Тип list. Изменяемость списка.

Тип кортежа tuple как замороженный список. Насколько не изменяем кортеж?

Список кортежей и цикл for с двумя переменными.

Тип строк str. Неизменяемость строки. Методы строки find, count, replace.

Срезы строк и списков.

Присваивание в срез списка.

Стандартные функции len, max, min, sum.

Методы split и join.

Структура данных Куча/Пирамида (Heap)



## Темы, рассмотренные на лекции №15:

## Темы, рассмотренные на лекции №16:

Тайм-коды: асимптотика алгоритмов
   0:00 Индуктивные функции. Однопроходные алгоритмы. Классификация алгоритмов не по асимптотике, а по тому, что они обрабатывают (число или последовательность) и что они возвращают (число или последовательность)
   
  13:57 однопроходный алгоритм - когда не нужно запоминать все числа. 
Индуктивная функция (F) - когда новая функция (следующего элемента) получается из известной предыдущей функции(F) и следующего элемента
  
  18:11 список F(f n , x)
  
  29:00   булевская сумма (хотя бы один / any),  булевское произведение (все / all)
  
  40:38   частотный анализ (frequency)
  
  42:13 асимптотика алгоритмов (потребление ресурсов)
  
  42:48 первый вопрос - вычислима ли функция
  
  43:58 первый ресурс, который потребляет алгоритм - память
  
  44:57 однопроходный алгоритм по памяти О(1)
  
  45:28 асимптотика по времени (по количеству операций): Nопер ~ Tработы # Nопер - входные параметры, масштаб задачи
  
  46:21 что такое асимптотика
  
  53:08 Nоп (max) = O(f(N))
  
  54:14 сравнение долгосрочных и краткосрочных алгоритмов
  
  57:18 классические асимптотики для функций:
О(1) - фиксированное время, не зависящее от количества чисел. (хэш-таблица поиска)
О(log N) - (поиск методом деления пополам)
О(N) - однопроходные алгоритмы. (частотный анализ)
1:01:08 логика (сортировка подсчетом)
O(N+M) # M - количество чисел
1:04:03 (сортировка по разрядам). не однопроходная, но линейная
O(N*M)
O(N*logN) (сортировка слиянием)
O(N**2) (квадратичные сортировки пузырьком, вставками, выбором)
O(N**3) (сортировка дурака, алгоритм на графах)
O(N!) 
O(2**N) (комбинаторные алгоритмы методом полного перебора)

1:07:31 NP- полные задачи

1:08:34 корень из х = половине х (по количеству разрядов в х)

1:09:24 асимптотика 1 числа - количество байт, которые занимают это число (количество двоичных разрядов в этом числе, количество цифр)

1:10:17 тест простоты Ферма. Фильтр, отсеивающий точно не простые, после которого уже доказывается простота оставшихся

1:16:05 числа Кармайкла

1:18:51 алгоритм шифрования RSA



## Темы, рассмотренные на лекции №17:

Тайм-коды: алгоритм факториал, алгоритм Фибоначчи, алгоритм задачи о рюкзаке
Рекурсия и динамическое программирование
   
   0:00 рекурсия - это способ решения задачи через вызов подзадач, аналогичных исходной задачи, но меньших по масштабу 
Крайний случай - это способ решения самой простой задачи, которая не требует вызова решения подзадачи
   
   1:23 алгоритм факториал рекурсивно
   
   4:46 алгоритм факториал динамически
   
   9:56 числа Фибоначчи. Постановка задачи
  
  13:44 алгоритм чисел Фибоначчи рекурсивно
  
  18:38 алгоритм чисел Фибоначчи динамически
  
  19:44 выделение памяти
  
  27:33 алгоритм чисел Фибоначчи рекурсивно с кешированием
Рекурсия с кешированием - это вариант динамического программирования, в котором используется рекурсия
  
  38:13 задача о рюкзаке. Задача оптимизационная. Постановка задачи. Вещи имеют массу и стоимость. Максимальная общая масса ограничена, нужна максимальная общая стоимость.
  
  42:15 решение полным перебором. Настоящее решение
  
  45:34 алгоритм жадный. Начинать брать с самых дорогих
  
  51:57 второй вариант жадности. Оптимизированный. Брать более драгоценные по плотности
  
  58:28 вариации решения
  
  59:27 дискретная задача о рюкзаке решается с помощью динамического программирования

1:00:08 целевая функция. F(i, k) - возвращает максимальную стоимость предметов, которую можно уложить массы k, при этом можно использовать только первые i предметов

1:01:44 дискретная задача о рюкзаке рекурсивно

1:14:14 алгоритм дискретной задачи о рюкзаке динамически




## Темы, рассмотренные на лекции №18:


Тайм-коды: ООП, Классы, Объекты, Именованный кортеж, Связный список
   
   0:19 классы. Объектно-ориентированное программирование
   
   2:24 класс - это тип объекта. Объект - это конкретный экземпляр этого типа
   
   2:57 абстрактный класс. Создание (class Goat)
   
   3:46 Атрибуты класса (константные переменные) пишутся в описании конкретного типа (сразу под именем класса) - некие свойства, которые свойственны этому классу. Классовый атрибут - свойство, присущее всем экземплярам этого класса
   
   5:15 Экземпляра класса, создание (marusya = Goat()). Идентификатор придумывается
   
   7:32 экземпляр класса (marusya) - сам представляет из себя пространство имен, т.е. конкретному экземпляру можно создавать свои свойства, свойственные только ей (marusya.horns = ) под новыми именами
   
   9:36 проблема тогда - нет единства объектов. Значит - нельзя припиливать атрибуты находу
  
  12:44 конструктор - для этого. (Функция def __init__) Делается в общем классе Goat
  
  13:40 __ имя __ - специализированный, магический метод
  
  14:18 Метод класса - любая функция в классе и его можно позвать для каждого конкретного экземпляра
  
  14:38 self - специальное имя - ссылка на текущий конкретный экземпляр. Первый параметр _init__(self, height, weight). Создавая каждый экземпляр обойти метод __init_ нельзя. Чтобы обратиться к методу init той самой козы, для экземпляра которой (маруся) этот метод вызван
  
  16:31 инициализация атрибутов конкретного экземпляра - главная цель конструктора
  
  18:18 можно указать значения по умолчанию для атрибутов
  
  18:37 def__str__(self): метод преобразования класса к строке
  
  20:26 форматирование строки: "  {},   {}".format(self.height, self.weight)  # self.height и self.weight вставятся попорядку вместо фигурных скобок в строку
  
  22:24 создание экземпляра с конструктором (marusya = Goat(60, 40)). Первый параметр self - невидим, но он есть всегда
  
  24:10 print (marusya) # автоматически запустит метод _str_
  
  26:02 объекты являются изменяемыми (notka.weight +=1)
  
  26:44 можно через несколько имен обращаться к одному объекту (a = marusya) # теперь у marusya 2 имени: a и marusya
  
  27:52 объекты можно складывать в списки, можно класть внутрь других объектов
  
  29:26 классовые атрибуты должны использоваться как константы
  
  31:00 если эту константу изменить в экземпляре, становится 2 совершенно разные переменные под одинаковыми именами (это если тип её - неизменяемый)
  
  32:10 если бы классовый атрибут был изменяемого типа (например list), то у всех поменялось бы значение, а не только у одного экземпляра. Меняешь что-то у одного экземпляра, а оно меняется у другого
  
  33:08 схема класса-объектов
  
  37:37 самый простой класс с телом pass
  
  38:14 не всегда реально нужны классы
  
  38:47 Именованные Кортежи. Для именования каждого элемента кортежа
  
  41:40 module collections (import collections)
  
  42:29 создание типа точка (Point = namedtuple("Point", "x y z") # ("имя типа", "список имён атрибутов через пробел")
  
  44:13 создание конкретного экземпляра точки (A = Point(1,0,3)). Это итерируемый объект
  
  47:00 Связный Список. Структура данных
a = [1]
a.append([2])
a[1].append([3,a])
  
  51:46 получается реальное хранимое данное и ссылка на следующий подобный объект
  
  52:34 чтобы пробежаться по нему от начала (begin) до конца (NoneType)
  
  54:34 делаем указатель и копируем туда ссылку (p = a)
while p is not None:
    print(p[0])
    p = p[1]     # перешагнуть на следующий
  
  58:19 в list вставить что-нибудь в начало затратно
  
  59:48 устройство оперативной памяти. Аллоцируемое пространство - зарезервированная память

1:02:16 у list кристаллическая структура, т.е. произвольный доступ RAM (random access memory) - оперативная память. Скорость доступа к i-му элементу за О(1)

1:03:40 скорость доступа к i-му элементу в связном (односвязном) списке за O(N)

1:05:44 вставка в начало в односвязный список мгновенна (a = [x, a])

1:07:12 алгоритм работы с односвязным списком class LinkedList:   init, insert, pop

1:08:54 по PEP8 имя атрибута класса должно начинаться с _ (одного подчеркивания)

1:10:40 можно реализовать магический метод __iter__, чтобы сделать итерируемый список

1:15:54 вызов методов LinkedList


## Темы, рассмотренные на лекции №19:

Тайм-коды: Дерево, Куча (Heap), алгоритм сортировка HeapSort
 
 0:00 дерево. Корень дерева -на вершине. Дальше - потомки
 
 0:30 двоичное дерево - если у дерева (у всех вершин) не больше двух потомков
 
 0:43 Куча - двоичное дерево с 3 свойствами:
         1) в вершинах значения не больше, чем в его потомке
 
 1:41 2) глубина всех листьев отличается не больше, чем на 1
 
 2:07 листья - вершины, которые не имеют потомков
 
 2:18 3) последний слой всегда наполняется слева направо без пробелов
 
 3:14 на вершине или максимум или минимум
 
 3:30 кучу удобно хранить в массиве. Потому что элементы идут последовательно
 
 4:05 у элемента i потомки будут: левый (i*2 + 1) и правый (i*2 + 2)
 
 5:08 предок для элемента i : (i-1)//2
 
 6:00 класс Куча (class Heap)
 
 7:06 метод insert (добавление элемента)  def sift_up (подвигать элемент с конца вверх по вершинам на свое место). В цикле while нужно обновлять i = (i - 1) // 2

13:32 метод extract-min (достать элемент из вершины)  def sift_down (подвигать последний элемент, поставленный в корень, вниз по вершинам на свое место). В цикле  while после всех операций обновлять i = j

26:49 время работы этих методов

30:30 алгоритм сортировка кучей (heapsort). Пирамидальная сортировка

35:40 def heapify. Функция преобразует массив к куче

36:53 def get_sorted_arr. Из кучи получает отсортированный массив

38:50 время работы

40:36 как сократить время сортировки
В куче количество элементов, которые имеют хотя бы одного потомка (N//2)

42:11 def heapify_fast. Преобразование массива в кучу, только если одновременно не вытаскиваются элементы

45:41 for i in reversed(range(heap.size//2)):  # оператор reversed разворачивает ряд задом наперед 

46:48 количество листьев (N/2 с округлением вверх), они находятся на высоте 0. Следующие вершины находятся на высоте +1, и количество них будет еще в 2 раза меньше (N/4 с округлением вверх)

47:33 время работы

50:00 формула убывающей геометрической прогрессии

51:20 случаи полезности heapify_fast. Чтобы строить кучу чуть-чуть быстрее, чем наивным способом

52:33 встроенный в Питоне модуль  heapq для работы с кучей



## Темы, рассмотренные на лекции №20:

Тайм-коды: Хеш-таблица
   
   0:00 Linked list/связные списки: односвязные и двусвязные (есть ссылка на предыдущий элемент)
   
   3:06 RAM (random access memory) память произвольного доступа
   
   4:08 Array / массив. Структура данных. Это некоторое количество последовательных ячеек в памяти. К произвольному элементу массива можно обратиться за О(1)
   
   5:55 Linked list  расширяемый. добавление и удаление элементов в список за О(1). Поиск элементов за О(N). Доступ по индексу за О(N)
   
   7:31 задача: добавление, удаление и поиск значения всё за О(1). В базе данных логинов и паролей, например. Не требуется искать данные по индексу (порядок пользователей в системе не важен). Безопасность важна
   
   9:53 1) решение - список телефонных номеров. Проблема - долгий поиск
  
  12:15 2) массив. Проблема - много места и данные в них хранятся очень разряженно
  
  13:53 Hash / Хеш-таблица -структура данных, реализующая интерфейс ассоциативного массива Н, элементы которого - пары (ключ, значение) и выполняет 3 операции: добавление, удаление, поиск. Это массив фиксированной длины. Недостаток - не сохраняет порядок элементов. Скорость: всё за О(1). Но эти операции м.б. не быстрыми
  
  15:25 проблема Коллизии (когда в 1 ячейку несколько значений может попасть). Принцип Дирихле
  
  16:15 Хеш-значение - индекс(номер ячейки, в которую положим), куда будут записаны хранимые данные (от тел. номера - ключа)
  
  17:07 2 решения:
  
  17:28 1) закрытая адресация (с цепочками)
  
  20:03 2) открытая адресация
  
  21:15 каким образом искать свободные ячейки по хеш-таблице. Последовательность проб - пробирование
  
  21:36 линейное пробирование
  
  26:19 задача: проверка наличия элемента в таблице
  
  32:58 квадратичное пробирование
  
  33:55 double -hashing /двойное хеширование
  
  37:24 Хеширование - это преобразование массива входных данных произвольной длины в битовую строку фиксированной длины, выполняемое определенным алгоритмом.
Хеш-функция (от ключа) - функция, реализующая алгоритм хеширования (преобразования произвольных данных к данным фиксированной длины)
Хеш (хеш-сумма, хеш-код, хеш-значение)(i = hash(key)) - результат выполнения хеширования. Играет роль индекса в массиве Н
  
  38:20 хеш-функции входных значений (массива) по ключу (алгоритм преобразования) в массив хешей. Хеши имеют фиксированную длину, битовую и небольшой диапазон, а значит можно определить его разрядность
  
  41:13 лавинный эффект (чуть-чуть меняются входные данные ->хеш изменяется существенно)
  
  42:14 нет взаимнооднозначного соответствия между входными данными и ответом
  
  43:21 ключевые свойства хеш-таблиц
  
  46:35 хорошие хеш-функция. Совершенная хеш-функция. Хеш-таблица с прямой адресацией
  
  49:56 применение хеш-функций
  
  52:12 примеры хеш-функций (не криптостойкие):
  
  52:21 остаток от деления H(x) = x mod N
  
  55:59 полиноминальный хеш
  
  58:30 XOR - хеширование

1:03:28 циклический избыточный код CRC (Cyclic redundancy check)

1:04:30 криптостойкие алгоритмы: MD (Message Digest) и SHA (Secure Hash Algorithm)

1:06:20 код в слайдах

1:11:45 производительность. Сравнение операции добавления: Списка и Хеш-таблицы

1:13:19 поиск

1:16:58 в Питоне 2 типа данных из коробки (встроенные хеш-таблицы):Словари (dict) ассоциативный массив и Множества (set)


## Темы, рассмотренные на лекции №21:

Тайм-коды: Множества / set, Словари / dict
   
   1:01 хеш-таблицы в Питоне
   
   3:41 реальная асимптотика хеш-таблицы
   
   9:54 перехеширование
  
  15:33 структура данных - это данные, которые организованы таким образом, чтобы доступаться к ним вполне определенными, конкретными алгоритмами, которые согласованы между собой
  
  18:29 Коллекции данных Python 3:
  
  19:01 1)tuple (кортеж)  x , y = f(x,y)   a[i]за О(1)
  
  20:00 2) list ("список") динамический массив ссылок   a.append(x)  a[i]за О(1)
  
  23:13 3) set (множество) хеш-таблица. всё за О(1)
  
  23:24 4) dict (словарь) хеш-таблица. всё за О(1)
  
  25:27 set и dict не строго типизированы (там могут храниться элементы разных типов). Элементы, добавляемые туда должны быть хешируемыми
  
  26:56 как устроено хранение в хеш-таблице: данные хранятся не упорядоченно
  
  27:40 Множества (set). Операции над множествами
  
  28:15 задается множество: А = {1, "2", 3}
Пустое множество задается не А = {}, а А = set(). Можно вставить любой итерируемый объект
  
  30:17 в множестве каждый элемент присутствует только 1 раз
  
  30:43 работа с элементами множества. Операции in, not in, add, discard, remove, pop
  
  36:58 операции над множествами: union, intersection, difference, symmetric_difference
  
  39:39 логические операции
  
  41:40 множество неупорядочиваемое
  
  45:47 Словари (dict)/ ассоциативные массивы
  
  48:11 создание: D = {}, D = dict(), D = {"one" : 1, "two" : 2, "three" : 3} # "one"  - ключ, 1 - значение ключа
  
  50:10 функция zip(A,B)
D = dict(zip(K , V)), K - список ключей, V - список значений
  
  54:26 операции над словарями

1:00:26 удаление: del A[key] , D.pop(key, -1)

1:03:35 итерирование по словарю. Перебор элементов словаря по ключу
for key in D или for key in D.keys()

1:08:01 постановка задачи. Словарь для частотного анализа по строкам

1:12:10 алгоритм частотного анализа

1:13:52 ключи могут быть только неизменяемого типа, значения - изменяемого

1:15:43 тип frozenset

1:17:07 получить коллекцию: A = list(x.items())  # items возвращает итерируемый список пар (ключ-значение)

1:20:31 реляционные базы данных основаны на хеш-таблицах

## Темы, рассмотренные на лекции №22:

Тайм-коды: Графы
   
   0:59 теория графов
   
   2:37 Вершина. Ребро
   
   5:51 Граф (неориентированный) - упорядоченная пара множеств (V , E), где V(vertexes) - множество вершин, E(edges) - множество неупорядоченных пар этих вершин
   
   7:28 ребро без вершины включать в граф нельзя
   
   8:16 вершины без ребер могут быть (изолированная вершина)
   
   8:53 V и E конечны
   
   9:25 вершины и ребра = элементы графа
  
  10:10 порядок графа |V| - число вершин в графе
           размер графа |E| - множество рёбер
  
  10:48 у каждого ребра 2 вершины (концы). Ребро соединяет эти вершины. Эти вершины - Соседние, смежные
  
  12:08 кратные рёбра - соединяют одни и те же вершины
  
  12:28 петля
  
  12:59 простой граф  - без петель и кратных рёбер
  
  13:35 степень вершины |deg V| - количество инцидентных ей (которые у неё есть) ребер
  
  14:33 соседство вершин (существует или нет между вершинами)
  
  15:27 лист, висячая вершина
  
  17:21 лемма о рукопожатиях - сумма всех степеней всех вершин(в графе) чётна
  
  17:52 петля считается в качестве степени два раза
  
  18:20 сумма всех степеней равна удвоенному количеству рёбер
  
  19:33 подграф
  
  20:30 сам граф является собственным подграфом
  
  20:40 пустой граф существует
  
  22:10 у промежуточной вершины в маршруте степень вершины уменьшается на 2 (оно чётное)
  
  22:46 только у стартовой вершины и финальной понижение степени может быть нечётным
  
  23:27 цикл. Циклический маршрут
  
  23:41 цикл Эйлера
  
  25:03 изоморфизм графов - отношение между графами, почти их эквивалентность
  
  25:28 графы А и В изоморфны, если существует биективное (взаимнооднозначное) отношение...
  
  31:01 планарность - если без пересечений рёбер
  
  33:56 Пути и циклы
  
  34:01 Маршрут - последовательность вершин и рёбер...
  
  37:30 длина маршрута - количество рёбер
  
  39:08 Цепь - маршрут без повторяющихся рёбер
  
  40:38 простая цепь - цепь без повторяющихся вершин
  
  41:19 Путь - ориентированный маршрут
  
  42:41 простой путь - рёбра не повторяются
  
  43:32 элементарный путь - и рёбра и вершины не повторяются
  
  44:43 Цикл - цепь, в которой первая и последняя вершины совпадают. Простой цикл
  
  46:43 свойства путей и циклов
  
  47:28 связность графов - две вершины связны, если есть цепь, их соединяющая
  
  48:54 отношение между вершинами как связность является отношением эквивалентности
  
  50:13 класс эквивалентности - множество всех вершин, которые эквивалентны друг другу (они все друг с другом связаны, пусть и не посредственно)
  
  51:21 Компонента связности - это подграф...
  
  54:43 количество компонент связности
  
  55:16 расстояние между вершинами (на компоненте связности)
  
  55:44 связный граф - с 1 компонентой связности
  
  56:33 мост
  
  57:48 точка сочленения
  
  59:48 Дерево - связный граф, в котором:

1) между любыми v1 v2 принадлежащих V есть только одна цепь

2) нет простых циклов

3)  |V| = |E| +1

1:05:24 корневое дерево - дерево, в котором одна из вершин корень

1:06:33 иерархичное дерево

1:09:34 высота графа - максимальное расстояние от корня до листа (количество рёбер до корня)

1:10:26 пустой граф не является деревом

1:12:36 бинарное дерево

1:12:54 диаметр

1:13:35 диаметр дерева - не превышает удвоенной его высоты

1:14:29 остовное дерево

1:18:17 вес ребра. Вес вершины

1:19:12 взвешенный граф - у которого все рёбра имеют вес


## Темы, рассмотренные на лекции №23:

Тайм-коды: варианты хранения Графа в памяти
   
   0:32 упаковка графа в память. Формы:
   
   1:29 1) список вершин + список рёбер
V = {'A', 'B', 'C', 'D'} ; E = {('A' , 'B'), ('B' , 'C'), ('C' , 'D')}
   
   7:51 асимптотика: скорость проверки вершины или ребра - О(1), проверка (перебор) всех соседних вершин - О(N)
  
  12:00 2) матрица смежности
V = ['A', 'B', 'C', 'D'] , index = {V[i]:i for i in range (len(V))} 
  
  14:40 dict comprehension
  
  17:39 матрица смежности схема
  
  19:13 подходит для простых графов
  
  22:21 все петли находятся на главной диагонали
  
  22:31 если граф неориентированный, то матрица симметрична относительно главной диагонали
  
  24:26 степень вершины (количество 1 в строке)
  
  24:45 в ориентированном графе есть исходящая степень и входящая
  
  25:38 двумерная матрица хранится как список списков
  
  27:04 асимптотика: скорость проверки вершины или ребра - О(1), проверка (перебор) всех соседних вершин - О(N)
  
  29:15 + простота реализации
  
  31:29 3) списки смежности  # словарь
  
  37:11 асимптотика: скорость проверки вершины или ребра - О(1), проверка (перебор) всех соседних вершин - О(от соседей)
  
  41:13 считывание графа с клавиатуры
  
  46:41 библиотека networx для работы с графами
  
  48:06 алгоритм считывания графа в матрицу смежности

1:01:44 алгоритм считывания графа в списки смежности

1:06:17 enumirate()  #  пронумеровывает итерируемые объекты

1:11:36 4) альтернативная форма хранения списка смежности: компактные списки смежности для неизменяемого графа

1:15:13 не хранят имена, а только индексы


## Темы, рассмотренные на лекции №24:

Тайм-коды: Графы. Алгоритм Косарайю, алгоритм Тарьяна, топологическая сортировка
  
   0:00 обход Графа в глубину. Приложения DFS (Deep First Search) обхода
   
   0:30 работа с графом. Приложения:
   
   2:34 1) выделить компоненту связности (найти все вершины, которые с ней связаны)
   
   3:56 схема граф 
  
  11:38 при помощи обхода в глубину найти минимальное остовное дерево нельзя
  
  12:20 остовное дерево
  
  12:58 2) подсчитать количество компонентов. Составить их список
  
  13:45 3) обнаружить простой цикл, где рёбра не повторяются ( но не самый короткий)
  
  17:26 4) проверить граф на двудольность. Двудольный граф
  
  21:58 5) искать мосты и точки сочленения
  
  22:49 работа с орграфом (ориентированным):
  
  23:19 компоненты сильной и слабой связности
  
  25:35 выделение сильных компонент орграфа. Алгоритм Косарайю
  
  26:10 топологическая сортировка
  
  26:35 алгоритм выделение компоненты связности def dfs
  
  28:51 изменяемый объект нельзя присваивать в параметр по умолчанию функции
а можно: def dfs(vertex, G, used = None):... 2 способа
  
  41:50 код алгоритм Косарайю
  
  49:31 компонента сильной связности находится
  
  56:29 топологическая сортировка. Алгоритм Тарьяна (не Прима) O(N)
  
  57:19 постановка задачи. Для графа без циклов. Это упорядочивание вершин

1:03:40 код алгоритм Тарьяна

1:13:52 использование обхода в глубину


## Темы, рассмотренные на лекции №25:



Обход графа в глубину (DFS).

Выделение и подсчёт компонент связности.

Проверка графа на двудольность.

Выделение компонент сильной связности орграфа алгоритмом Косарайю.

Топологическая сортировка через алгоритм Тарьяна.



Тайм-коды: обход Графов в ширину / Breadth first search (BFS)
   
   0:28 план
   
   0:56 Очередь (Queue). Структура обращения к данным. First in, first out. add (enqueue) / remove (dequeue). В отличии от стека
   
   2:15 3 реализации очереди:

1) queue = []   O(N) по времени

2) queue = list(range(1000))  # неэффективно по памяти  O(1)

3) библиотека from collections import deque   O(1)   add - append(), remove - popleft()
   
   6:42 очередь через двусвязный список
   
   7:18 ссылки на документацию по deque:

https://docs.python.org/3/library/collections.html#collections.deque

https://pythontips.com/2014/07/02/an-intro-to-deque-module/
   
   7:28 невзвешенные графы. Алгоритм работает и на ориентированных и на неориентированных графах
   
   8:02 Обход графов в ширину. Все рёбра одинаковые, у каждого вес - 1. Расстояние между двумя точками - измеряется в количестве рёбер, которые содержит минимальный путь
   
   8:22 граф будет храниться в виде списка смежности (словарь с множествами)
   
   9:20 обход графа в ширину (иллюстрация)
  
  13:00 Приложения алгоритма:

- поиск кратчайшего расстояния от центральной вершины до всех других
  
  15:00 - нахождение циклов
  
  15:14 очередь чтобы обеспечивать правильный порядок обхода вершин
  
  18:00 асимптотика O(N+M)
  
  18:04 алгоритм код считывание графа     
map(int, input().split())
  
  23:02 код, который считывает расстояние
  
  28:57 код обход в ширину с комментариями
  
  29:07 Приложения:
  
  31:32 - выделение компонент связности
  
  32:20 - восстановление кратчайшего пути
  
  36:50 - восстановление траектории шахматного коня
  
  39:18 алгоритм код: Конь
  
  49:32 обход в ширину может находить разные пути
  
  50:38 - нахождение кратчайшего цикла
  
  51:33 - нахождение всех рёбер / вершин на кратчайшем пути
  
  53:07 - кратчайший путь чётной длины
  
  54:50 - нахождение наиболее короткой цепочки друзей между двумя пользователями ВК
  
  55:33 HTTP - запросы, VK api
  
  55:52 алгоритм код
  
  58:07 json() - текстовый формат обмена данными (что-то вроде словаря) из JavaScript



## Темы, рассмотренные на лекции №26:



Взвешенный граф

Обход графа в ширину.

Очередь при обходе в ширину и её асимптотика.

Выделение компонент связности (обходом в ширину).

Нахождение кратчайшего цикла в невзвешенном графе.

Поделиться:



Тайм-коды: Графы, кратчайший путь, алгоритм Дейкстры с очередью, алгоритм Флойда-Уоршелла
   
   0:07 графы, кратчайшие расстояния, способы их поиска
   
   0:18 взвешенные графы. Вес - это число, назначаемое рёбрам. Не обязательно число положительное. Может быть вектором
   
   0:46 Алгоритм Дейкстры поиска кратчайшего расстояния в графе
   
   3:08 это обход графа в ширину с перезажиганием. В взвешенном графе
   
   4:48 требования: веса - положительное число ( или 0)
   
   5:25 асимптотика O(N**2)
   
   7:35 цель: поиск кратчайшего пути от исходной вершины ко всем
   
   9:57 логика алгоритма
  
  16:45 приоритезированная очередь. Грязная очередь
  
  28:03 итог - расстояние
  
  28:27 восстановление пути. Последовательность рёбер
  
  39:02 3 варианта алгоритма Дейкстры
  
  39:52 код алгоритма Дейкстры
  
  42:28 assert
  
  57:04 def dijkstra(G, start):

1:03:48 алгоритм Флойда-Уоршелла основан на идее динамического программирования. Работает удобно в формате матрицы весов

1:05:01 цель - кратчайшие расстояния от каждой вершины к каждой

1:05:51 асимптотика O(N**3)

1:06:30 +: работает в случае наличия отрицательных рёбер (работает с отрицательными весами, но не циклами отрицательного веса

1:07:18 эти алгоритмы работают и с ориентированными графами

1:07:34 он может детектировать цикл отрицательного веса

1:08:02 логика алгоритма Флойда-Уоршелла






## Темы, рассмотренные на лекции №27:


Двоичные деревья поиска.

Асимптотика основных операций.

Балансировка деревьев.

Малый левый и правый повороты.

Большой левый и правый повороты.


Тайм-коды: Двоичное дерево поиска, балансировка дерева, малый левый/правый поворот, большой левый/правый поворот
   
   0:17 как хранятся деревья - граф, в котором нет циклов, связный
   
   0:46 корневое дерево - дерево, в котором 1 вершина называется корнем, выделенная вершина
   
   0:55 уровни вершин. Дочерние вершины. Родительская вершина. Листья
   
   2:32 пустой граф не является деревом
   
   3:30 структура данных дерево
   
   3:54 Бинарное/Двоичное дерево - корневое дерево, где у любой вершины не более двух дочерних
   
   4:47 высота дерева H - максимальное количество рёбер от корня до листа
   
   6:05 порядок, последовательность дочерних вершин имеет значение, упорядоченное корневое дерево
   
   8:11 двоичные деревья поиска (дв.д.п.)
   
   8:40 главное свойство - у каждой вершины есть ключ
   
   8:57 дв.д.п. - структура данных, хранящая в вершинах элементы, содержащие ключ и принадлежащие множеству потенциальных ключей, упорядоченному линейно. При этом на ключах есть сравнимость (k1<k2)
  
  12:54 пример
  
  18:20 асимптотика. Добавление, удаление, поиск время пропорционально H (высоте дерева)
  
  19:21 в дерево влезает много элементов таблица
  
  22:16 сбалансированное дерево, несбалансированное дерево
  
  25:03 Балансировка дерева
  
  27:46 дв.д.п. - упорядоченная структура данных
  
  30:24 дерево является сбалансированным, если для каждой вершины высота её левого и правого поддеревьев отличается не более, чем на 1
  
  32:03 хорошее дв.д.п
  
  36:36 что делать, чтобы сбалансировать
  
  37:49 простейшие элементы балансировки. 2 алгоритма дв.д.п.: АВЛ -дерево и Красно-чёрное дв.д.п.
  
  39:12 добавление элемента. Для всех вершин перевычисляется дисбаланс (подсчитываются высоты левых и правых поддеревьев)
  
  41:26 Малый левый поворот
  
  49:04 Большой правый поворот - это комбинация малого левого и малого правого поворотов
  
  57:41 дв.д.п. не требует массива. Организуется на ссылках. Это связные списки
  
  58:22 Звено дв.д.п.  - объект с key, value, и 3-мя ссылками: parent, left, right

1:00:53 код class Node


## Темы, рассмотренные на лекции №28:



Цикл Эйлера и цикл Гамильтона.

Жадный алгоритм Дейкстры

Алгоритм Флойда-Уоршелла



Тайм-коды: цикл Эйлера и цикл Гамильтона, жадный алгоритм Дейкстры, алгоритм Флойда-Уоршелла
   
   2:19 Эйлеров цикл (цикл, который проходит через каждое ребро графа и причем только 1 раз).
Гамильтонов цикл (через каждую вершину)
   
   5:19 Эйлеров граф (в котором есть Эйлеров цикл). Гамильтонов граф
   
   8:12 как проверить является ли граф Эйлеровым или Гамильтоновым:
   
   8:35 признаки Эйлерова: 1) связный, 2) все степени вершин чётные
  
  11:58 для Гамильтонова графа признаков нет. Задача NP полна. Решается полным перебором
  
  20:03 Жадный алгоритм Дейкстры. Без очереди. Задача - кратчайший путь от одной вершины ко всем остальным. Ответ - массив. Работает на ориентированных графах
  
  30:43 Алгоритм Флойда-Уоршелла. Задача - кратчайшее расстояние от каждой вершины к каждой. Ответ - матрица. Алгоритм динамического программирования
  
  44:35 Ф-У работает на ориентированных графах. Асимптотика O(N**3)
  
  45:21 Ф-У преимущество - работает и в случае наличия отрицательных весов
  
  45:32 Дейкстра не работает с отрицательными весами
  
  46:24 Ф-У не работает с циклами отрицательных весов




